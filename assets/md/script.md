# 🎯 React 코어 딥다이브 세미나 슬라이드 구성안

## 📊 전체 구조 (30분 기준)

**총 슬라이드 수**: 약 25-30장
**발표 시간**: 30분 (각 슬라이드당 평균 1분)

---

## 슬라이드별 구성

### 🎬 Slide 1: 타이틀 슬라이드

**시간**: 30초

**내용**:

```
리액트를 까본 사람 손🙋
(Virtual DOM부터 Fiber까지)

여찬규
2025.11.XX
```

**이미지**:

- 배경: React 로고 (흐릿하게)
- 또는 코드 배경 이미지

**대사**:

> "안녕하세요! 오늘은 React를 완전히 까보는 시간을 가져보려고 합니다. 평소에 우리가 당연하게 써왔던 React가 내부적으로 어떻게 동작하는지, Virtual DOM부터 Fiber Architecture까지 30분 동안 함께 알아보겠습니다!"

---

### 📝 Slide 2: 오늘의 목표

**시간**: 30초

**내용**:

```
오늘 배울 것

✅ JSX → JavaScript 변환 과정
✅ Virtual DOM의 진짜 의미
✅ Reconciliation 알고리즘
✅ 얕은 비교와 불변성
✅ Fiber Architecture
```

**이미지**:

- 체크리스트 아이콘들
- 또는 로드맵 형태

**대사**:

> "오늘은 크게 5가지 주제를 다룰 건데요. 각 주제가 서로 연결되어 있어서 순서대로 따라오시면 전체 그림이 보이실 겁니다. 목표는 '아 그래서 React가 이렇게 동작하는구나'를 느끼는 거예요!"

---

### 🎭 Section 1: JSX

### Slide 3: JSX를 처음 봤을 때

**시간**: 1분

**내용**:

```jsx
function HelloWorld() {
	return <h1>Hello, World!</h1>;
}
```

```
이게... JavaScript?? 🤔
```

**이미지**:

- 코드 스크린샷
- 물음표 이모지 크게

**대사**:

> "여러분 처음 JSX 봤을 때 어땠나요? 저는 '어? JavaScript에서 HTML을 쓴다고?'라고 생각했어요. 근데 이거, 사실은 JavaScript가 아닙니다!"

---

### Slide 4: Babel의 마법

**시간**: 1분 30초

**내용**:

```
Before (JSX)
<h1>Hello</h1>

        ↓ Babel 변환

After (JavaScript)
React.createElement('h1', null, 'Hello')
```

**이미지**:

- 좌우 split 화면
- 화살표로 변환 과정 강조
- Babel 로고

**대사**:

> "JSX는 Babel이 JavaScript로 변환해줍니다. 보시면 `React.createElement`라는 함수 호출로 바뀌죠. 그럼 이 함수가 뭘 반환할까요?"

---

### Slide 5: React Element = JavaScript 객체

**시간**: 1분 30초

**내용**:

```javascript
{
  type: 'div',
  props: {
    className: 'container',
    children: [
      { type: 'h1', props: { children: '제목' } },
      { type: 'p', props: { children: '내용' } }
    ]
  }
}
```

```
이게 바로 Virtual DOM의 시작! 🌳
```

**이미지**:

- 객체 구조를 트리 형태로 시각화
- JSX → 객체 변환 흐름도

**대사**:

> "결국 JavaScript 객체를 만드는 거예요! 이 객체가 바로 Virtual DOM을 구성하는 노드입니다. HTML처럼 보이지만 사실은 전부 JavaScript 객체인 거죠."

---

### 🌳 Section 2: Virtual DOM

### Slide 6: jQuery 시대의 고통

**시간**: 1분

**내용**:

```javascript
$("#user-name").text(newName);
$("#user-age").text(newAge);
$("#user-email").text(newEmail);
// ... 수십 개의 업데이트
```

```
문제점:
❌ 성능 (DOM 조작 비용)
❌ 유지보수 (코드 분산)
❌ 버그 (추적 불가)
```

**이미지**:

- jQuery 로고 (흑백)
- 복잡하게 얽힌 코드 이미지
- 머리 아픈 개발자 이모지

**대사**:

> "Virtual DOM 이야기를 하기 전에, 왜 필요했는지부터 보죠. jQuery 시대에는 데이터가 바뀔 때마다 DOM을 일일이 찾아서 업데이트했어요. 코드는 복잡해지고 버그는 양산되죠."

---

### Slide 7: Virtual DOM의 등장

**시간**: 1분 30초

**내용**:

```
1. 상태 변경
   ↓
2. 새로운 Virtual DOM 생성
   ↓
3. 이전 Virtual DOM과 비교 (Diffing)
   ↓
4. 바뀐 부분만 실제 DOM에 반영
```

**이미지**:

- 플로우차트 형태
- Virtual DOM(메모리) vs Real DOM(브라우저) 분리
- 화살표로 흐름 표시

**대사**:

> "Virtual DOM의 핵심 아이디어는 간단합니다. 상태가 바뀌면 새로운 Virtual DOM을 만들고, 이전 것과 비교해서 바뀐 부분만 실제 DOM에 반영하는 거예요. 그런데 여기서 중요한 오해가 하나 있습니다..."

---

### Slide 8: Virtual DOM의 진실

**시간**: 1분

**내용**:

```
❌ 오해: "Virtual DOM이 항상 빠르다!"

✅ 진실: "충분히 빠르다 + 개발 경험 개선"

목적 = 선언적 프로그래밍
```

```
React vs jQuery

React: "이렇게 보여줘" (What)
jQuery: "이거 찾아서 저거 바꿔" (How)
```

**이미지**:

- X표와 체크 아이콘
- Dan Abramov 트윗 스크린샷 (있다면)
- 대비되는 코드 예시

**대사**:

> "많은 분들이 'Virtual DOM이 빠르니까 쓴다'고 생각하는데, 사실 목적은 성능이 아니라 개발 경험이에요. 우리가 What만 신경 쓰면 How는 React가 알아서 해주는 거죠!"

---

### ⚙️ Section 3: Reconciliation

### Slide 9: 불가능한 문제

**시간**: 1분

**내용**:

```
트리 비교의 복잡도: O(n³)

1,000개 노드 = 10억 번 연산 😱

60fps = 16ms 안에 계산 완료 필요

→ 불가능!
```

**이미지**:

- 복잡도 그래프 (지수 증가)
- 타이머 이미지 (16ms 강조)
- 불가능 표시

**대사**:

> "두 개의 트리를 비교하는 건 원래 엄청 복잡한 문제예요. O(n³) 복잡도라서 노드가 1000개만 되어도 10억 번 연산을 해야 합니다. 60fps를 유지하려면 16ms 안에 끝내야 하는데, 이건 불가능하죠. React는 어떻게 해결했을까요?"

---

### Slide 10: React의 두 가지 가정

**시간**: 1분 30초

**내용**:

```
가정 1: 다른 타입 = 다른 트리
<div> → <span> = 전체 재생성!

가정 2: key로 안정적인 식별
<li key={item.id}>
```

```
O(n³) → O(n) 달성! 🎉
```

**이미지**:

- 2개의 박스로 가정 분리
- 복잡도 그래프 (급감)
- 트리 구조 다이어그램

**대사**:

> "React는 두 가지 과감한 가정으로 O(n)을 달성했습니다. 첫째, 타입이 다르면 완전히 다른 UI라고 가정하고 비교하지 않고 새로 만듭니다. 둘째, key를 통해 요소를 식별합니다. 이 두 가정 덕분에 엄청난 성능 향상을 이뤄낸 거죠!"

---

### Slide 11: key가 중요한 이유

**시간**: 2분

**내용**:

```
❌ 나쁜 예: index를 key로
[
  <li key={0}>Apple</li>
  <li key={1}>Banana</li>
]
→ 맨 앞에 Orange 추가하면?
[
  <li key={0}>Orange</li>  // key 0이지만 새 아이템
  <li key={1}>Apple</li>   // key 1이지만 Apple
  <li key={2}>Banana</li>  // key 2로 변경
]
React: "0번이랑 1번 내용만 바뀌었네?"
→ 불필요한 리렌더링! 😱
```

**이미지**:

- Before/After 애니메이션 GIF
- 잘못된 key 사용 시 문제점 시각화
- 리렌더링 하이라이트

**대사**:

> "이게 바로 우리가 늘 듣는 'key warning'의 이유입니다. index를 key로 쓰면 React가 요소를 제대로 식별하지 못해요. 새 아이템을 추가했는데 React는 기존 아이템이 바뀐 줄 알고 불필요하게 전부 리렌더링하죠. 그래서 반드시 고유한 ID를 key로 사용해야 합니다!"

---

### Slide 12: Diffing 알고리즘

**시간**: 1분 30초

**내용**:

```
1. 같은 레벨끼리만 비교
   └─ 트리 전체 순회 불필요

2. 같은 타입이면 props만 업데이트
   └─ DOM 노드 재사용

3. 컴포넌트 타입이 같으면
   └─ 인스턴스 유지, state 유지!
```

**이미지**:

- 트리 레벨 비교 다이어그램
- props 업데이트 플로우
- 3단계 프로세스 시각화

**대사**:

> "Diffing 알고리즘의 핵심은 3가지입니다. 같은 레벨끼리만 비교하고, 타입이 같으면 props만 업데이트하고, 컴포넌트가 같으면 state를 유지합니다. 이 마지막 포인트가 리렌더링 시에도 state가 사라지지 않는 이유예요!"

---

### 🔄 Section 4: 얕은 비교

### Slide 13: 얕은 비교 vs 깊은 비교

**시간**: 1분

**내용**:

```javascript
// 얕은 비교 (React)
Object.is(prevState, nextState);

// 깊은 비교 (React가 안 하는 것)
JSON.stringify(prevState) === JSON.stringify(nextState);
```

```
왜 얕은 비교?
✅ 빠르다 (참조만 비교)
✅ 예측 가능하다
✅ 명시적이다
```

```javascript
왜 === 대신 Object.is?
• NaN === NaN → false
• Object.is(NaN, NaN) → true

• +0 === -0 → true
• Object.is(+0, -0) → false

→ 더 정확한 동등성 비교
→ useEffect, useMemo의 deps 비교에 사용
```

**이미지**:

- 좌우 split (얕은 vs 깊은)
- Object.is vs === 비교표
- 성능 비교 그래프
- 체크 아이콘

**대사**:

> "React는 상태가 바뀌었는지 확인할 때 얕은 비교만 합니다. 참조만 비교하는 거죠. 깊은 비교는 중첩된 모든 객체를 순회해야 해서 느립니다. 대신 우리가 불변성을 지켜야 하죠!"
>
> "그리고 여기서 중요한 포인트 하나! React는 ===가 아닌 Object.is를 사용합니다. 왜냐하면 === 는 NaN과 NaN을 비교하면 false가 나오고, +0과 -0을 비교하면 true가 나오거든요. Object.is는 이런 엣지 케이스를 더 정확하게 처리합니다. useEffect나 useMemo의 의존성 배열을 비교할 때 바로 이 Object.is를 사용하는 겁니다!"

---

### Slide 14: 불변성의 중요성

**시간**: 2분

**내용**:

```javascript
// ❌ 나쁜 예
user.age = 26;
setUser(user); // 참조가 같아서 리렌더링 안 됨!

// ✅ 좋은 예
setUser({ ...user, age: 26 }); // 새로운 참조!
```

```
불변성을 지켜야 하는 이유:
→ React가 변화를 감지할 수 있게!
```

**이미지**:

- X표와 체크 아이콘
- 메모리 참조 다이어그램
- Before/After 비교

**대사**:

> "이게 바로 우리가 항상 스프레드 연산자를 쓰는 이유입니다. 직접 수정하면 참조가 같아서 React가 변화를 감지하지 못해요. 새 객체를 만들어야 참조가 바뀌면서 리렌더링이 일어나죠. 복잡하면 Immer 같은 라이브러리를 쓰면 됩니다!"

---

### Slide 15: 다른 프레임워크와의 비교

**시간**: 1분

**내용**:

```
Vue: Proxy 기반 → 자동 감지
Angular: Zone.js → 모든 이벤트 추적
React: 명시적 불변성 → 개발자가 제어
```

```
React의 철학
"마법보다는 명시성"
```

**이미지**:

- 3개 프레임워크 로고
- 비교 표
- React 로고 강조

**대사**:

> "Vue나 Angular는 자동으로 변화를 감지해줍니다. 편하죠. 하지만 React는 '명시적'을 선택했어요. 더 번거롭지만, 코드를 읽었을 때 정확히 무슨 일이 일어나는지 알 수 있다는 장점이 있습니다!"

---

### 🧵 Section 5: Fiber

### Slide 16: React 16 이전의 문제

**시간**: 1분

**내용**:

```javascript
function processTree(node) {
	node.children.forEach((child) => {
		processTree(child); // 중단 불가!
	});
	updateNode(node);
}
```

```
문제점:
❌ 동기적 처리 (중단 불가)
❌ 긴 작업이 UI 멈춤
❌ 버벅거림 😱
```

**이미지**:

- 재귀 호출 스택 시각화
- 멈춘 UI 화면
- 답답한 느낌의 이미지

**대사**:

> "React 16 이전에는 Stack Reconciler를 썼는데요. 재귀적으로 모든 작업을 한 번에 처리했습니다. 문제는 중단할 수 없다는 거예요. 대규모 리스트를 렌더링할 때 입력이 먹통되는 경험, 다들 해보셨죠? 바로 이 때문입니다!"

---

### Slide 17: Fiber의 해결책

**시간**: 1분 30초

**내용**:

```
Fiber = 작업을 작은 단위로 쪼개기

Stack: [==================] (중단 불가)
        UI 먹통 😱

Fiber: ─┬─┬─┬─┬─┬─ (중단 가능)
        사용자 입력 처리! 😊
```

```
핵심 특징:
✅ 인터럽트 가능
✅ 우선순위 스케줄링
✅ 동시성
```

**이미지**:

- Stack vs Fiber 비교 다이어그램
- 작업 단위 시각화
- 우선순위 큐

**대사**:

> "Fiber는 작업을 작은 단위로 쪼개서, 중요한 것부터 먼저 처리하고, 필요하면 중간에 멈추고 다시 시작할 수 있습니다. 사용자 입력은 즉시 처리하고, 검색 결과 업데이트 같은 건 뒤로 미룰 수 있는 거죠!"

---

### Slide 18: 우선순위 스케줄링

**시간**: 1분 30초

**내용**:

```javascript
// 즉시 (클릭, 입력)
ReactDOM.flushSync(() => {
	setUrgentState(newValue);
});

// 일반
setState(newValue);

// 낮음 (분석, 로깅)
startTransition(() => {
	setLowPriorityState(newValue);
});
```

**이미지**:

- 우선순위 레벨 표
- 코드 예시
- useTransition 사용 예시

**대사**:

> "Fiber는 작업에 우선순위를 매길 수 있습니다. 클릭이나 입력 같은 사용자 인터랙션은 최우선으로 처리하고, 데이터 페칭이나 로깅 같은 건 나중에 처리하죠. useTransition이나 Suspense 같은 기능도 모두 Fiber 덕분에 가능한 겁니다!"

---

### Slide 19: 개발자가 알아야 할 것

**시간**: 1분

**내용**:

```javascript
// ❌ 부작용이 있으면 안 됨!
function Component() {
	console.log("렌더링!"); // 여러 번 찍힐 수 있음
	callAPI(); // 절대 안 됨!
	return <div>Hello</div>;
}

// ✅ 순수 함수로 작성
function Component() {
	return <div>Hello</div>;
}

// ✅ 부작용은 useEffect에서
useEffect(() => {
	callAPI();
}, []);
```

**이미지**:

- X표와 체크 아이콘
- 순수 함수 개념 다이어그램
- useEffect 사용 예시

**대사**:

> "Fiber는 렌더링을 중단하고 다시 시작할 수 있기 때문에, 컴포넌트 함수가 여러 번 호출될 수 있습니다. 그래서 반드시 순수 함수로 작성해야 해요. API 호출 같은 부작용은 useEffect에서 처리해야 합니다!"

---

### 📊 Section 6: 마무리

### Slide 20: 우리가 배운 것들

**시간**: 1분

**내용**:

```
1️⃣ JSX → React.createElement → JS 객체

2️⃣ Virtual DOM → 선언적 프로그래밍

3️⃣ Reconciliation → O(n) 알고리즘

4️⃣ 얕은 비교 → 불변성

5️⃣ Fiber → 우선순위 스케줄링
```

**이미지**:

- 5개 주제 아이콘
- 연결된 플로우차트
- React 로고

**대사**:

> "오늘 배운 내용을 정리해볼게요. JSX가 JavaScript 객체로 변환되고, 이게 Virtual DOM을 구성하고, Reconciliation으로 효율적으로 비교하고, 얕은 비교로 빠르게 감지하고, Fiber로 우선순위를 관리합니다. 모두 연결되어 있죠!"

---

### Slide 21: 실무 활용

**시간**: 1분 30초

**내용**:

```
이제 이해할 수 있는 것들:

✅ key warning이 왜 뜨는지
✅ 왜 불변성을 지켜야 하는지
✅ 언제 React.memo를 써야 하는지
✅ 왜 컴포넌트를 순수 함수로 작성하는지
```

```
성능 최적화 팁:
• 올바른 key 사용
• 불변성 유지
• React.memo 적절히 사용
• React DevTools Profiler 활용
```

**이미지**:

- 체크리스트
- React DevTools 스크린샷
- 최적화 전후 성능 비교

**대사**:

> "이제 여러분은 React를 더 깊이 이해하게 되었습니다. key warning이 왜 뜨는지, 왜 불변성을 지켜야 하는지, 언제 최적화를 해야 하는지 이해할 수 있죠. 이 지식은 실무에서 성능 문제를 디버깅하고 더 나은 코드를 작성하는 데 큰 도움이 될 거예요!"

---

### Slide 22: 더 공부하기

**시간**: 30초

**내용**:

```
추천 자료:
📚 React 공식 문서 - Reconciliation
🎥 Lin Clark's Fiber 설명
💻 React Source Code

다음 단계:
→ React 소스코드 읽어보기
→ 직접 간단한 React 구현해보기
→ 성능 최적화 실전 프로젝트
```

**이미지**:

- 책 아이콘
- 링크 QR 코드
- GitHub 로고

**대사**:

> "더 깊이 공부하고 싶으시면 React 공식 문서와 Lin Clark의 Fiber 설명 영상을 추천드립니다. 여유가 되시면 React 소스코드를 직접 읽어보거나, 간단한 React를 직접 구현해보는 것도 큰 도움이 될 거예요!"

---

### Slide 23: Q&A

**시간**: 5분

**내용**:

```
질문 있으신가요? 🙋
```

**이미지**:

- 물음표 이미지
- 또는 토론하는 사람들 이미지

**대사**:

> "발표는 여기까지입니다. 궁금하신 점이나 더 자세히 알고 싶은 부분 있으시면 질문해주세요!"

---

### Slide 24: Thank You

**시간**: 10초

**내용**:

```
감사합니다! 🙏

여찬규
blog: blog9yu.dev
github: @chan9yu
```

**이미지**:

- 감사 이미지
- 연락처 정보

**대사**:

> "끝까지 들어주셔서 감사합니다. 혹시 나중에 더 궁금하신 게 있으시면 블로그나 GitHub로 연락주세요!"

---

## 💡 추가 팁

### 슬라이드 디자인 원칙

1. **간결함**: 슬라이드당 핵심 메시지 1개
2. **시각화**: 코드보다는 다이어그램 우선
3. **대비**: 중요한 부분은 색상으로 강조
4. **일관성**: 같은 색상 팔레트, 폰트 사용

### 발표 팁

1. **시간 배분**: 각 섹션마다 타이머 체크
2. **청중 참여**: "경험해보신 분?" 같은 질문 던지기
3. **예시 활용**: 실무 경험 공유하기
4. **속도 조절**: 중요한 부분은 천천히, 반복

### 준비물

- 라이브 코딩 대비 (Babel REPL, React DevTools)
- 백업 슬라이드 (더 깊은 질문 대비)
- 데모 준비 (key warning 재현, 성능 비교 등)
